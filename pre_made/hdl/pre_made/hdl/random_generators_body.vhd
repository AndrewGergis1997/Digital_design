--
-- VHDL Package Body hds_package_library.random_generators
--
-- Created:
--
-- Generated by Mentor Graphics' HDL Designer(TM) 
--
LIBRARY ieee;
USE ieee.std_logic_1164.ALL;

PACKAGE BODY random_generators IS

-- Mathematical functions needed to perform the random number generation
    
    --pow - claulates powers for real numbers
    FUNCTION pow ( val : REAL ; p : REAL) RETURN real is
    BEGIN
         if  not( p = real(integer(p)) ) then
            assert (val>0.0) report "Output for function pow is complex " severity FAILURE; 
         elsif ( (p/2.0) = real(integer(p/2.0)) ) then
            assert (val>0.0) report "Output for function pow is imaginary " severity FAILURE;
         end if;    
    RETURN (exp( p * log(val) ) );  
    END;

    -- modl - calculates the modolus of a real number
    FUNCTION modl (val : REAL ) RETURN real IS
    BEGIN
        if (val >= 0.0) then
        RETURN val;
        else
        RETURN (-1.0)* val;
        end if;
    END modl;    
     
    -- isqrt - Calculates the square root of a real number in the range 0 to 2
    FUNCTION isqrt ( val : REAL ) RETURN  real IS
       variable sum, term, valpower, correction, coeff, inrangeval, factorial, i: real;
    BEGIN
        assert (val>=0.0) report "Function sqrt called on a negative value" severity FAILURE; 
        inrangeval := val;
        correction := 1.0;
        while ( inrangeval >= 1.0 ) loop
             inrangeval := inrangeval / 4.0;
             correction := correction * 2.0;
        end loop;       
        i := 0.0;
        coeff := 1.0;
        factorial := 1.0;
        sum := 0.0;
        term := 1.0;
        valpower := 1.0;
        while ((sum /= sum+term)) loop
             sum := sum + term;
             coeff := coeff * (0.5-i);
             valpower := valpower * (inrangeval-1.0);
             factorial := factorial * (i+1.0);
             term := coeff * valpower / factorial;
             i := i + 1.0;
         end loop;
         RETURN (sum* correction);
    END isqrt;
    
    --sqrt - calculates the square root of any 
    FUNCTION sqrt ( val : REAL ) RETURN real is
       variable ival: real;
           
    BEGIN
        if val=0.0 then
    RETURN 0.0;
        elsif (val <1.0) then
        ival :=1.0/val;
    RETURN (1.0/isqrt(ival));
        else
        RETURN (isqrt(val));
        end if;
   END sqrt;
   
    -- exp - Calculates the exponential of a real number
    FUNCTION exp ( val : REAL )  RETURN  real IS
       variable intval : integer;
       variable fracval, expfracval, expintval : real;
       constant e : real := 2.718281828;
    BEGIN
       intval := integer(floor(val));
       fracval := val - real(intval);
       expintval := e**intval;
       expfracval := 1.0+fracval*(1.0+0.5*fracval*(1.0+0.333334*fracval*(1.0+0.25*fracval*(1.0+0.2*fracval*(1.0+0.1666667*fracval*(1.0+0.142857*fracval))))));  
       RETURN expintval*expfracval;     
    END exp;

    -- log10 - Calculates the 10th based logarithm of a real number
    FUNCTION log10 ( val : REAL )  RETURN  real IS
    BEGIN
       assert (val>0.0) report "Function log called on negative or zero value" severity FAILURE; 
       RETURN (0.434294482 * log(val));
    END log10;

    -- ilog - Calculates the natural logarithm of a real number larger than 0.001 
    FUNCTION ilog ( val : REAL )   RETURN  real IS
       variable sum, term, valpower, correction, coeff, inrangeval, i: real;
       constant e : real := 2.718281828;
    BEGIN
       assert (val>0.0) report "Function log called on negative or zero value" severity FAILURE; 
       inrangeval := val;
       correction := 0.0;
       while ( inrangeval >= 2.0 ) loop
            inrangeval := inrangeval / e;
            correction := correction + 1.0;
       end loop;
       i := 2.0;
       coeff := 1.0;
       sum := 0.0;
       valpower := inrangeval-1.0;
       term := (inrangeval-1.0);
       while ( sum /= sum+term ) loop
            sum := sum + term;
            coeff := coeff * (-1.0);
            valpower := valpower * (inrangeval-1.0);
            term := coeff * valpower / i;
            i := i + 1.0;
       end loop;
       RETURN (sum+correction);
    END ilog;
   
    --log - calculates the natural logarithm for any real number
    
    FUNCTION log ( val : REAL )   RETURN  real IS
       variable v : real;       
    BEGIN
       if (val < 0.001 ) then 
           v := val * 1.0e6;
    RETURN (ilog(v) - ilog(1.0e6));
       else
    RETURN ilog(val);
       end if;
    END log;

    -- floor - Calculates the largest integral value less than or equal to a real number
    FUNCTION floor ( val : REAL )   RETURN  real IS
       variable y : integer;
    BEGIN
        y := integer(val);
        if real(y)=val then
            RETURN real(y);
        elsif real(y)>val then
            RETURN real(y-1);
        else
            RETURN real(y);
        end if;
    END floor;

    -- ceil - Calculates the smallest integral value greater than or equal to a real number
    FUNCTION ceil ( val : REAL )   RETURN  real IS
       variable y : integer;
    BEGIN
        y := integer(val);
        if real(y)=val then
            RETURN real(y);
        elsif real(y)<val then
            RETURN real(y+1);
        else
            RETURN real(y);
        end if;
    END ceil;

    -- isin - Calculates the sin value of a real number is in between 0 and PI/4 to converge
    FUNCTION isin  ( val : REAL )   RETURN  real IS
       variable sum, term, valpower, correction, coeff, signset, factorial, i : real;
    BEGIN
       i := 3.0;
       coeff := 1.0;
       factorial := 6.0;
       sum := 0.0;
       term := val;
       signset := -1.0;
       valpower := val;
       while ( sum /= sum+term ) loop
           sum := sum + term;
           coeff := coeff * signset;
           valpower := valpower * val * val;
           term := coeff * valpower / factorial;
           factorial := factorial * (i+1.0) * (i+2.0);
           i := i + 2.0;
       end loop;
       RETURN (sum);
    END isin;

    -- icos - Calculates the cos value of a real number val is in between 0 and PI/4 to converge
    FUNCTION icos  ( val : REAL )   RETURN  real IS
       variable sum, term, valpower, correction, coeff, signset, i, factorial : real;
    BEGIN
       i := 2.0;
       coeff := 1.0;
       factorial := 1.0;
       sum := 0.0;
       term := 1.0;
       signset := -1.0;
       valpower := 1.0;
       while ( sum /= sum+term ) loop
           sum := sum + term;
           coeff := coeff * signset;
           valpower := valpower * val * val;
           factorial := factorial * i;
           term := coeff * valpower / factorial;
           factorial := factorial * (i+1.0);
           i := i + 2.0;
       end loop;
       RETURN (sum);
    END icos;

    -- sin - Calculates the sin value of any gradient number
    FUNCTION sin  ( val : REAL )   RETURN  real IS
       variable inrangeval, signset, twopi, piover2, threepiover2 : real;
    BEGIN
       inrangeval := abs(val);
       twopi := 2.0*PI;
       piover2 := PI/2.0;
       threepiover2 := 3.0*PI/2.0;
       signset := 1.0;
       while ( inrangeval >= twopi ) loop
            inrangeval := inrangeval - twopi;
       end loop;
       if (inrangeval>=piover2 and inrangeval<PI) then
           inrangeval := PI-inrangeval;
           signset := 1.0;
       elsif (inrangeval>=PI and inrangeval<threepiover2) then
           inrangeval := inrangeval-PI;
           signset := -1.0;
       elsif (inrangeval>=threepiover2 and inrangeval<twopi) then
           inrangeval := twopi-inrangeval;
           signset := -1.0;
       end if;              
       RETURN 2.0*signset*isin(inrangeval/2.0)*icos(inrangeval/2.0);
    END sin;

    -- cos - Calculates the cos value of any gradient number
    FUNCTION cos  ( val : REAL )   RETURN  real IS
       variable inrangeval, signset, twopi, piover2, threepiover2,test: real;
    BEGIN
       inrangeval := val;
       twopi := 2.0*PI;
       piover2 := PI/2.0;
       threepiover2 := 3.0*PI/2.0;
       signset := 1.0;
       test := val/PI;
       if (real(val/(pi/2.0)) = real(integer(val/(pi/2.0)))) and
          not(test = real(integer(test))) then
         RETURN 0.00;       
       else
       while ( inrangeval >= twopi ) loop
            inrangeval := inrangeval - twopi;
       end loop;
       if (inrangeval>=piover2 and inrangeval<PI) then
           inrangeval := PI-inrangeval;
           signset := -1.0;
       elsif (inrangeval>=PI and inrangeval<threepiover2) then
           inrangeval := inrangeval-PI;
           signset := -1.0;
       elsif (inrangeval>=threepiover2 and inrangeval<twopi) then
           inrangeval := twopi-inrangeval;
           signset := 1.0;
       end if;              
       RETURN signset*((2.0*icos(inrangeval/2.0)*icos(inrangeval/2.0))-1.0);
       end if;
    END cos;

    -- tan - Calculates the tan value of any gradient number
    FUNCTION tan  ( val : REAL )   RETURN  real IS
       variable sinval, cosval : real;
    BEGIN
       sinval := sin(val);
       cosval := cos(val);
       assert (cosval/=0.0) report "Function tan called on N*PI+PI/2 value, where N is an integer number" severity FAILURE;              
       RETURN sin(val)/cos(val);
    END tan;

    -- gammln - Calculates the natural logarithmic value of a gamma function
    FUNCTION gammln  ( val : REAL )   RETURN  real IS
       type realarr is array (0 to 5) of real;
       variable x, y, tmp, ser, finalval : real;
       constant cof : realarr := 
               ( 0 =>  76.18009172947146,
                 1 => -86.50532032941677,
                 2 =>  24.01409824083091,
                 3 => -1.231739572450155,
                 4 =>  0.1208650973866179e-2,
                 5 => -0.5395239384953e-5
                );
    BEGIN
       assert (val>0.0) report "Function gammln called on negative or zero value" severity FAILURE;
       y := val;
       x := val;
       tmp := x+5.5;
       tmp := tmp - (x+0.5) * log(tmp);
       ser := 1.000000000190015;
       for i in 0 to 5 loop
           y := y + 1.0;
           ser := ser + cof(i)/y;
       end loop;
       finalval := (-1.0)*tmp+log(2.5066282746310005*ser/x);
       RETURN finalval;
    END gammln;

-- Random number generation functions

    -- random - Returns a uniform number value between 0.0 and 1.0
    -- VHDL implementation of Park and Miller with Pays-Durham shuffle and added safeguards
    -- Reference Numerical Recipes In C book, Chapter 7, page 280

    PROCEDURE random ( variable seed : inout INTEGER; variable rndval : out REAL; variable iv : inout genstatus1) IS
       constant IA : integer := 16807;
       constant IM : integer := 2147483647;
       constant AM : real := (1.0/real(IM));
       constant IQ : integer := 127773;
       constant IR : integer := 2836;
       constant NTAB : integer := 32;
       constant NDIV : real := (1.0+(real(IM)-1.0)/real(NTAB));
       constant EPS  : real := 1.2e-7;
       constant RNMX : real := (1.0-EPS);
       variable temp : real;
       variable j, k : integer;
    BEGIN
       if (seed <= 0) then
          if ((-1*seed) < 1) then 
              seed := 1;
          else 
              seed := -1 * seed;
          end if;
          j := NTAB+7;      
          while (j >= 0) loop
              k := seed/IQ;
              seed := IA*(seed-k*IQ)-IR*k;
              if (seed < 0) then 
                  seed := seed + IM;
              end if;      
              if (j < NTAB) then 
                  iv(j) := seed;
              end if;
          j := j - 1;
          end loop;
          iv(NTAB) := iv(0);      
       end if;

       k := seed/IQ;
       seed := IA*(seed-k*IQ)-IR*k;
       if (seed < 0) then
           seed := seed + IM;
       end if;
       j := integer(floor(real(iv(NTAB))/real(NDIV)));
       iv(NTAB) := iv(j);  
       iv(j) := seed;
       temp := AM*real(iv(NTAB));
       if (temp > RNMX) then 
           rndval := RNMX;
       else 
           rndval := temp;
       end if;      

    END random;

    -- dist_uniform - Returns a uniform number value between start and end

    PROCEDURE dist_uniform (variable seed : inout INTEGER; variable rndval : out INTEGER; startpoint : REAL; endpoint : REAL; variable iv : inout genstatus1 ) IS
       variable rndval01 : real;      
    BEGIN

       random(seed, rndval01, iv);
       rndval := integer(startpoint + (endpoint-startpoint)*rndval01);

    END dist_uniform;

     -- dist_normal - Returns a random number with normal (Gaussian) distribution
     -- Reference Numerical Recipes In C  book, Chapter 7, page 289

    PROCEDURE dist_normal (variable seed : inout INTEGER; variable rndval : out INTEGER; mean : REAL; stddev : REAL; variable iv : inout genstatus1; variable iy : inout genstatus2 ) IS
       variable rand : real;      
    BEGIN
         assert (stddev>0.0) report "Standurd deviation is negative or zero" severity FAILURE;
         dist_normal ( seed , rand , mean , stddev , iv , iy );
         rndval := integer(rand);    

    END dist_normal;


    PROCEDURE dist_normal (variable seed : inout INTEGER; variable rndval : out REAL; mean : REAL; stddev : REAL; variable iv : inout genstatus1; variable iy : inout genstatus2 ) IS
       variable fac, rsq, v1, v2 : real;      
    BEGIN
    assert (stddev>0.0) report "Standurd deviation is negative or zero" severity FAILURE;

-- iy(0) represents variable "gset"
-- iv(NTAB+1) represents variable "iset" should be initialized to 0 before this procedure is called

       if ( seed < 0 ) then
          iv(NTAB+1) := 0;
       end if;
       if ( iv(NTAB+1) = 0 ) then
            random(seed, v1, iv);
            random(seed, v2, iv);
            v1:=2.0*v1 - 1.0;
            v2:=2.0*v2 - 1.0;
            rsq := v1*v1 + v2*v2 ;
            while ( rsq >= 1.0 or rsq = 0.0 ) loop
                 random(seed, v1, iv);
                 random(seed, v2, iv);
                 v1:=2.0*v1-1.0;
                 v2:=2.0*v2-1.0;
                 rsq := v1*v1+v2*v2;
            end loop;
            fac := sqrt(-2.0*log(rsq)/rsq);
            iy(0) := v1 * fac;
            iv(NTAB+1) := 1;
            rndval := v2 * fac * stddev + mean;
       else
            iv(NTAB+1) := 0;
            rndval := iy(0) * stddev + mean;            
       end if;
       
    END dist_normal;

    -- dist_exponential - Returns a random number with exponential distribution
    -- Reference Numerical Recipes In C book, Chapter 7, page 287

    PROCEDURE dist_exponential (variable seed : inout INTEGER; variable rndval : out INTEGER; mean : REAL; variable iv : inout genstatus1 ) IS
       variable rand : real;      
    BEGIN
    
       dist_exponential(seed,rand,mean,iv);  
       rndval := integer(rand);
       
    END dist_exponential;

    PROCEDURE dist_exponential (variable seed : inout INTEGER; variable rndval : out REAL; mean : REAL; variable iv : inout genstatus1 ) IS
       variable rndval01 : real := 0.0;      
    BEGIN

       while ( rndval01 = 0.0 ) loop
           random(seed, rndval01, iv);
       end loop;

       rndval := -1.0 * mean * log(rndval01);

    END dist_exponential;

     -- dist_poisson - Returns a random number with poisson distribution
     -- Reference Numerical Recipes In C book, Chapter 7, page 294

    PROCEDURE dist_poisson (variable seed : inout INTEGER; variable rndval : out INTEGER; mean : REAL; variable iv : inout genstatus1; variable iy : inout genstatus2 ) IS
       variable em, t, y, ran1val : real;      
    BEGIN
   
-- iy(3) represents oldm, should be initialized to -1.0 before this procedure is called
-- iy(2) represents variable "g"
-- iy(1) represents variable "alxm"
-- iy(0) represents variable "sq"

       if ( mean < 12.0 ) then
            if (mean /= iy(3)) then           
                  iy(3) := mean;
                  iy(2) := exp(-1.0*mean); 
            end if;
            em := -1.0;
            t := 1.0;
            while (true) loop
                 em := em + 1.0;
                 random(seed, ran1val, iv);
                 t := t * ran1val;         
                 if ( t <= iy(2) ) then
                      exit;
                 end if;
            end loop;
       else
            if (mean /= iy(3)) then           
                  iy(3) := mean;
                  iy(0) := sqrt(2.0 * mean);
                  iy(1) := log(mean);
                  iy(2) := mean*iy(1)-gammln(mean+1.0);
            end if;
            while (true) loop
                  while (true) loop
                      random(seed, ran1val, iv);
                      y := tan(PI*ran1val);
                      em := iy(0)*y+mean;
		            if ( em >= 0.0 ) then
  		            	exit;
    		            end if;
                  end loop;
            em := floor(em);
            t := 0.9*(1.0+y*y)*exp(em*iy(1)-gammln(em+1.0)-iy(2));

            random(seed, ran1val, iv);
            if ( ran1val <= t ) then
                  exit;
            end if;
            end loop;
 
       end if;
                rndval := integer(em);
    END dist_poisson;
    
    -- dist_gamma - Returns a random number with gamma distribution
    -- Reference   L. Devroye, "Non-Uniform Random Variate Generation" 
    
    PROCEDURE dist_gamma (variable seed : inout INTEGER; variable rndval : out REAL; alpha : REAL; beta : REAL; variable iv : inout genstatus1) IS
    variable c,d,u,v,x,e,y,aa,bb,w,z,r,zlog,xlog,xy,bby,v2,w3,y2 : real ;  
    BEGIN
      
      r :=0.0; 
      assert ((alpha >0.0) and (beta>0.0)) report "gamma distribution with one or more negative parameters" severity FAILURE;
      
      if ( alpha =1.0 )  then
          
          -- If alpha == 1, then gamma is exponential. (Devroye, page 405).
          
          dist_exponential(seed,rndval,beta,iv);  
          
      elsif ( alpha < 1.0 ) then
          
          -- (Devroye, page 418 - Johnk's generator)
          
          c := 1.0/alpha ;
          d := 1.0/(1.0-alpha);
          while (r=0.0) loop
             random ( seed , u , iv );
             random ( seed , v , iv );
             x := pow(u,c);
             y := pow(v,d); 
             if ( (x+y) <= 1.0) then
                 random ( seed , aa , iv );
                 e := -log(aa);
                 r := e*x/(x+y);
             end if;
          end loop; 
          r:=r*beta;
      else
          -- Use a rejection method for alpha > 1.
          -- (Devroye, page 410 Best's algorithm)

          bb := alpha-1.0;     
          c  := 3.0 * alpha - ( 3.0/4.0);
          while (r=0.0) loop
              random ( seed , u , iv );
              random ( seed , v , iv );
              w := u * (1.0-u);
              y := sqrt(c/w) * (u-0.5);
              x := bb + y;
              if ( x >= 0.0) then 
                 w3:=w*w*w;
                 v2:=v*v;
                 z := 64.0 * w3 * v2;
                 y2:= y*y;
                 zlog := log(z);
                 xlog:=log(x/bb);
                 xy := (1.0- (2.0*y2/x));
                 bby :=2.0*( (bb * xlog) - y );
                 if ( z <= xy)  then
                    r := x;
                 elsif  (zlog <= bby ) then
                    r := x ;
                 end if ;
              end if ;
          end loop;
          r := r * beta;
      end if ;
      rndval := r ;
    END dist_gamma; 
   
    -- dist_chi_square - Returns a random number with chi-squared distribution
    -- Reference  L. Devroye, "Non-Uniform Random Variate Generation"

    PROCEDURE dist_chi_square (variable seed : inout INTEGER; variable rndval : out INTEGER ; n : REAL ; variable iv : inout genstatus1) IS 
    variable a,b, rand : real;
   
    BEGIN
       b := 2.0;
       a := n/2.0;
       dist_gamma(seed,rand,a,b,iv);
       rndval := integer(rand);
    END dist_chi_square;

    --dist_erlang - Returns a random number with erlang distribution
    --use gamma_dist with alpha being intrger...  
    PROCEDURE dist_erlang(variable seed : inout INTEGER; variable rndval : out INTEGER ; alpha : REAL ;beta : REAL; variable iv : inout genstatus1) IS
       variable alpha1, rand : real;
    
    BEGIN
       alpha1 := real(floor(alpha));
       dist_gamma(seed,rand,alpha1,beta,iv);
       rndval := integer(rand);
    END dist_erlang;
    
   -- dist_t -  Returns a random number with t distribution
   -- Refrence  L. Devroye, "Non-Uniform Random Variate Generation"
  
   PROCEDURE dist_t (variable seed : inout INTEGER; variable rndval : out INTEGER ; n : REAL ; variable iv : inout genstatus1;variable iy: inout genstatus2) IS 
      variable r,u,v,x : real; 
   BEGIN
      assert (n>0.0) report "No. of degrees of freedom must be postive " severity FAILURE;
      r :=0.0;
      if (n = 1.0) then  -- When n = 1 the T and Cauchy distributions are the same.
                         -- Generate Cauchy random numbers as a ratio of normal. 
                         --Devroye p. 451. 

         dist_normal ( seed , u , 0.0 , 1.0 , iv , iy );  
         dist_normal ( seed , v , 0.0 , 1.0 , iv , iy );   
         r := u/v;
      elsif (r=2.0) then
                         --When n = 2, express T random numbers as a function of uniform
                         --random numbers.  See Devroye, page 430, Theorem 4.1, part C.


         random ( seed , u , iv );
         r := sqrt(2.0) * (u - 0.5) / sqrt(u*(1.0-u));
      
          else
                       -- Otherwise, express t random numbers as a function of symmetric
                       -- beta random numbers. See Devroye, page 446, number 3.


         dist_beta(seed,x,(n/2.0),(n/2.0),iv); 
         r := sqrt(n) * (x - 0.5) / sqrt(x * (1.0 - x));
      end if;
      rndval  := integer(r) ;   
   END dist_t;

   --dist_beta - Returns a random number with beta distribution
   --Use Theorem 4.1, case A (Devroye, page 430) to derive beta
   -- random numbers as a ratio of gamma random numbers.

   PROCEDURE dist_beta (variable seed : inout INTEGER; variable rndval : out REAL ; a : REAL ; b : REAL ; variable iv : inout genstatus1) IS  
      variable g1 , g2 : real;
   BEGIN
      assert ((a >0.0) and (b>0.0)) report "beta distribution with one or more negative parameters" severity FAILURE;
      random ( seed , g1 , iv ) ;
      random ( seed , g2 , iv ) ;
      rndval := ( g1 / (g1+g2) ) ;
   END dist_beta;

END random_generators;

