//----------------------------------------------------------------------
//   THIS IS AUTOMATICALLY GENERATED CODE
//   Generated by Mentor Graphics' Register Assistant V4.2 (Build 2)
//----------------------------------------------------------------------
// Project         : Output
// File            : C:\RA_Flow\Output\..\Output\reg_block.v
//----------------------------------------------------------------------
// Created by      : user
// Creation Date   : 04 12 2012 14:21::03
//----------------------------------------------------------------------

//----------------------------------------------------------------------
// Block           : reg_block
// Address Range   : 0x20
//----------------------------------------------------------------------
// Description: 
//    Register Block
//----------------------------------------------------------------------
// Block Settings:
//    rtl.BLOCK_LABEL_CASE          : LOWER
//    rtl.BUS_TYPE                  : AMBA_APB
//    rtl.CLOCK                     : clock
//    rtl.CLOCK_EDGE                : POSITIVE
//    rtl.CONSTANT_CASE             : UPPER
//    rtl.DECLARE_INFERRED_SIGNALS  : TRUE
//    rtl.DEFAULT_FIELD             : def_fld
//    rtl.DEFAULT_RDATA_NAME        : def_rdata_val
//    rtl.DEFAULT_RDATA_VALUE       : 0
//    rtl.DEFAULT_SCALAR_INPUT_TYPE : wire
//    rtl.DEFAULT_SCALAR_OUTPUT_TYPE: reg
//    rtl.DEFAULT_VECTOR_INPUT_TYPE : wire
//    rtl.DEFAULT_VECTOR_OUTPUT_TYPE: reg
//    rtl.FIELD_INPUT_RW0C_SUFFIX   : _clr_n
//    rtl.FIELD_INPUT_RW0S_SUFFIX   : _set_n
//    rtl.FIELD_INPUT_RW1C_SUFFIX   : _clr
//    rtl.FIELD_INPUT_RW1S_SUFFIX   : _set
//    rtl.FIELD_INPUT_SUFFIX        : _ip
//    rtl.FIELD_NAMING              : %(FIELD_NAME)_%(REGISTER_INSTANCE_NAME)
//    rtl.FILE_NAME                 : %(BLOCK_NAME).v
//    rtl.IDENTIFIER_CASE           : AS_IS
//    rtl.LANGUAGE                  : VLOG_2005
//    rtl.LOCALPARAM_CASE           : UPPER
//    rtl.PARAMETER_CASE            : UPPER
//    rtl.QUEUED_FIELD_SUFFIX       : _queued
//    rtl.RESET                     : reset
//    rtl.RESET_LEVEL               : HIGH
//    rtl.RESET_STYLE               : ASYNC
//    rtl.VHDL_IEEE_REFERENCE_CASE  : LOWER
//    rtl.VHDL_KEYWORD_CASE         : UPPER
//----------------------------------------------------------------------

module reg_block
#(
  parameter ADDR_WIDTH=6,
  parameter DATA_WIDTH=16
)
(
  // FIELD OUTPUT PORTS
  output reg          ctrl_bit_status_reg_h   ,
  output reg   [15:0] data_RegA_h             ,
  output reg   [15:0] data_RegB_h             ,
  output reg   [15:0] data_small_mem_h_array_0,
  output reg   [15:0] data_small_mem_h_array_1,
  output reg   [15:0] data_small_mem_h_array_2,
  output reg   [15:0] data_small_mem_h_array_3,
  output reg   [15:0] data_small_mem_h_array_4,
  output reg   [15:0] data_small_mem_h_array_5,
  output reg   [15:0] data_small_mem_h_array_6,
  output reg   [15:0] data_small_mem_h_array_7,

  // INPUT PORTS
  input wire          ctrl_bit_status_reg_h_ip   ,
  input wire   [15:0] data_RegB_h_ip             ,
  input wire   [15:0] data_small_mem_h_array_0_ip,
  input wire   [15:0] data_small_mem_h_array_1_ip,
  input wire   [15:0] data_small_mem_h_array_2_ip,
  input wire   [15:0] data_small_mem_h_array_3_ip,
  input wire   [15:0] data_small_mem_h_array_4_ip,
  input wire   [15:0] data_small_mem_h_array_5_ip,
  input wire   [15:0] data_small_mem_h_array_6_ip,
  input wire   [15:0] data_small_mem_h_array_7_ip,

  // SIGNALS INFERRED FROM USER CONDITION-ACTIONS

  input wire  cnt,
  input wire  eof,


  // GENERIC BUS PORTS
  input  wire                  clock   , // Register Bus Clock
  input  wire                  reset   , // Register Bus Reset
  input  wire [ADDR_WIDTH-1:0] waddr   , // Write Address-Bus
  input  wire [ADDR_WIDTH-1:0] raddr   , // Read Address-Bus
  input  wire [DATA_WIDTH-1:0] wdata   , // Write Data-Bus
  output reg  [DATA_WIDTH-1:0] rdata   , // Read Data-Bus
  input  wire                  rstrobe , // Read-Strobe
  input  wire                  wstrobe , // Write-Strobe
  output reg                   raddrerr, // Read-Address-Error
  output reg                   waddrerr, // Write-Address-Error
  output reg                   wack    , // Write Acknowledge
  output reg                   rack      // Read Acknowledge
);

  // READ/WRITE ENABLE SIGNALS
  reg  wen_status_reg_h       ;
  reg  wen_RegA_h             ;
  reg  wen_RegB_h             ;
  reg  wen_small_mem_h_array_0;
  reg  wen_small_mem_h_array_1;
  reg  wen_small_mem_h_array_2;
  reg  wen_small_mem_h_array_3;
  reg  wen_small_mem_h_array_4;
  reg  wen_small_mem_h_array_5;
  reg  wen_small_mem_h_array_6;
  reg  wen_small_mem_h_array_7;

  // MUX INPUTS FOR EACH REGISTER WITH READ ACCESS
  wire [DATA_WIDTH-1:0] rmux_status_reg_h       ;
  wire [DATA_WIDTH-1:0] rmux_RegA_h             ;
  wire [DATA_WIDTH-1:0] rmux_RegB_h             ;
  wire [DATA_WIDTH-1:0] rmux_small_mem_h_array_0;
  wire [DATA_WIDTH-1:0] rmux_small_mem_h_array_1;
  wire [DATA_WIDTH-1:0] rmux_small_mem_h_array_2;
  wire [DATA_WIDTH-1:0] rmux_small_mem_h_array_3;
  wire [DATA_WIDTH-1:0] rmux_small_mem_h_array_4;
  wire [DATA_WIDTH-1:0] rmux_small_mem_h_array_5;
  wire [DATA_WIDTH-1:0] rmux_small_mem_h_array_6;
  wire [DATA_WIDTH-1:0] rmux_small_mem_h_array_7;

  // DEFAULT VALUE FOR READ DATA BUS
  localparam DEF_RDATA_VAL = 16'h0000;

  // ADDRESS PARAMETERS
  localparam STATUS_REG_H_ADDR = 6'h00;
  localparam REGA_H_ADDR = 6'h02;
  localparam REGB_H_ADDR = 6'h04;
  localparam SMALL_MEM_H_ARRAY_0_ADDR = 6'h10;
  localparam SMALL_MEM_H_ARRAY_1_ADDR = 6'h12;
  localparam SMALL_MEM_H_ARRAY_2_ADDR = 6'h14;
  localparam SMALL_MEM_H_ARRAY_3_ADDR = 6'h16;
  localparam SMALL_MEM_H_ARRAY_4_ADDR = 6'h18;
  localparam SMALL_MEM_H_ARRAY_5_ADDR = 6'h1a;
  localparam SMALL_MEM_H_ARRAY_6_ADDR = 6'h1c;
  localparam SMALL_MEM_H_ARRAY_7_ADDR = 6'h1e;


  //----------------------------------------------------------------------
  //                    WRITE ADDRESS DECODE
  //----------------------------------------------------------------------
  always @ ( * )
  begin : write_enable
    wen_status_reg_h <= 1'b0;
    wen_RegA_h <= 1'b0;
    wen_RegB_h <= 1'b0;
    wen_small_mem_h_array_0 <= 1'b0;
    wen_small_mem_h_array_1 <= 1'b0;
    wen_small_mem_h_array_2 <= 1'b0;
    wen_small_mem_h_array_3 <= 1'b0;
    wen_small_mem_h_array_4 <= 1'b0;
    wen_small_mem_h_array_5 <= 1'b0;
    wen_small_mem_h_array_6 <= 1'b0;
    wen_small_mem_h_array_7 <= 1'b0;
    waddrerr <= 1'b0;
    wack <= 1'b0;

    if (wstrobe)
    begin
      case (waddr)
        STATUS_REG_H_ADDR:
        begin
          wen_status_reg_h <= 1'b1;
        end
        REGA_H_ADDR:
        begin
          wen_RegA_h <= 1'b1;
        end
        REGB_H_ADDR:
        begin
          wen_RegB_h <= 1'b1;
        end
        SMALL_MEM_H_ARRAY_0_ADDR:
        begin
          wen_small_mem_h_array_0 <= 1'b1;
        end
        SMALL_MEM_H_ARRAY_1_ADDR:
        begin
          wen_small_mem_h_array_1 <= 1'b1;
        end
        SMALL_MEM_H_ARRAY_2_ADDR:
        begin
          wen_small_mem_h_array_2 <= 1'b1;
        end
        SMALL_MEM_H_ARRAY_3_ADDR:
        begin
          wen_small_mem_h_array_3 <= 1'b1;
        end
        SMALL_MEM_H_ARRAY_4_ADDR:
        begin
          wen_small_mem_h_array_4 <= 1'b1;
        end
        SMALL_MEM_H_ARRAY_5_ADDR:
        begin
          wen_small_mem_h_array_5 <= 1'b1;
        end
        SMALL_MEM_H_ARRAY_6_ADDR:
        begin
          wen_small_mem_h_array_6 <= 1'b1;
        end
        SMALL_MEM_H_ARRAY_7_ADDR:
        begin
          wen_small_mem_h_array_7 <= 1'b1;
        end
        default:
        begin
          waddrerr <= 1'b1;
        end
      endcase
      wack <= 1'b1;
    end
  end


  //------------------------------------------------------------
  // Register: status_reg
  //   Status register
  //   SW Access     : read-write
  //   Address Offset: 0x0
  //   HW Access     : read-write
  // 
  // Instance: status_reg_h
  //   Status register instance
  //   Address Offset: 0x0
  //   Reset Value   : 
  // 
  // Fields:
  //   15:1  reserved (SW:read-write, HW:read-write) (RESERVED) 
  //     0  ctrl_bit (SW:read-write, HW:read-write)

  //------------------------------------------------------------
  //   Field: reserved (reserved)                          
  //   Width: 15                  , Offset: 1              
  //   SW Access: read-write      , HW Access: read-write  
  //------------------------------------------------------------
  //   Reserved
  //

  //------------------------------------------------------------
  //   Field: ctrl_bit                                
  //   Width: 1              , Offset: 0              
  //   SW Access: read-write , HW Access: read-write  
  //------------------------------------------------------------
  //   Control bit
  //
  always @ (posedge clock or posedge reset)
  begin : reg_status_reg_ctrl_bit_status_reg_h
    // Reset
    if ( reset )
      ctrl_bit_status_reg_h <= 1'b0;
    // SW:read-write
    else if (wen_status_reg_h)
      ctrl_bit_status_reg_h <= wdata[0];
    // HW:read-write
    else
      ctrl_bit_status_reg_h <= ctrl_bit_status_reg_h_ip;
  end


  //------------------------------------------------------------
  // Register: RegA
  //   Register A
  //   SW Access     : read-write
  //   Address Offset: 0x2
  //   HW Access     : read-write
  // 
  // Instance: RegA_h
  //   Reg A instance
  //   Address Offset: 0x2
  //   Reset Value   : 
  // 
  // Fields:
  //   15:0  data (SW:read-write, HW:read-write)

  //------------------------------------------------------------
  //   Field: data                                    
  //   Width: 16             , Offset: 0              
  //   SW Access: read-write , HW Access: read-write  
  //------------------------------------------------------------
  //   RegisterA field
  //
  always @ (posedge clock or posedge reset)
  begin : reg_rega_data_rega_h
    // Reset
    if ( reset )
      data_RegA_h <= 16'h0000;
    // SW:read-write
    else if (wen_RegA_h)
      data_RegA_h <= wdata;
    // HW (customized)
    else if (eof=1'b1)
      data_RegA_h <= cnt+1; // Increment the counter.
  end


  //------------------------------------------------------------
  // Register: RegB
  //   Register B
  //   SW Access     : read-write
  //   Address Offset: 0x4
  //   HW Access     : read-write
  // 
  // Instance: RegB_h
  //   Reg B instance
  //   Address Offset: 0x4
  //   Reset Value   : 
  // 
  // Fields:
  //   15:0  data (SW:read-write, HW:read-write)

  //------------------------------------------------------------
  //   Field: data                                    
  //   Width: 16             , Offset: 0              
  //   SW Access: read-write , HW Access: read-write  
  //------------------------------------------------------------
  //   Register B field
  //
  always @ (posedge clock or posedge reset)
  begin : reg_regb_data_regb_h
    // Reset
    if ( reset )
      data_RegB_h <= 16'h0000;
    // SW:read-write
    else if (wen_RegB_h)
      data_RegB_h <= wdata;
    // HW:read-write
    else
      data_RegB_h <= data_RegB_h_ip;
  end


  //------------------------------------------------------------
  // Register: small_mem
  //   Small register-based memory
  //   SW Access     : read-write
  //   Address Offset: 0x10
  //   HW Access     : read-write
  // 
  // Instance: small_mem_h_array_0
  //   Memory instances
  //   Address Offset: 0x10
  //   Reset Value   : 
  // 
  // Fields:
  //   15:0  data (SW:read-write, HW:read-write)

  //------------------------------------------------------------
  //   Field: data                                    
  //   Width: 16             , Offset: 0              
  //   SW Access: read-write , HW Access: read-write  
  //------------------------------------------------------------
  //   Memory cell field
  //
  always @ (posedge clock or posedge reset)
  begin : reg_small_mem_data_small_mem_h_array_0
    // Reset
    if ( reset )
      data_small_mem_h_array_0 <= 16'hFFFF;
    // SW:read-write
    else if (wen_small_mem_h_array_0)
      data_small_mem_h_array_0 <= wdata;
    // HW:read-write
    else
      data_small_mem_h_array_0 <= data_small_mem_h_array_0_ip;
  end


  //------------------------------------------------------------
  // Register: small_mem
  //   Small register-based memory
  //   SW Access     : read-write
  //   Address Offset: 0x10
  //   HW Access     : read-write
  // 
  // Instance: small_mem_h_array_1
  //   Memory instances
  //   Address Offset: 0x12
  //   Reset Value   : 
  // 
  // Fields:
  //   15:0  data (SW:read-write, HW:read-write)

  //------------------------------------------------------------
  //   Field: data                                    
  //   Width: 16             , Offset: 0              
  //   SW Access: read-write , HW Access: read-write  
  //------------------------------------------------------------
  //   Memory cell field
  //
  always @ (posedge clock or posedge reset)
  begin : reg_small_mem_data_small_mem_h_array_1
    // Reset
    if ( reset )
      data_small_mem_h_array_1 <= 16'hFFFF;
    // SW:read-write
    else if (wen_small_mem_h_array_1)
      data_small_mem_h_array_1 <= wdata;
    // HW:read-write
    else
      data_small_mem_h_array_1 <= data_small_mem_h_array_1_ip;
  end


  //------------------------------------------------------------
  // Register: small_mem
  //   Small register-based memory
  //   SW Access     : read-write
  //   Address Offset: 0x10
  //   HW Access     : read-write
  // 
  // Instance: small_mem_h_array_2
  //   Memory instances
  //   Address Offset: 0x14
  //   Reset Value   : 
  // 
  // Fields:
  //   15:0  data (SW:read-write, HW:read-write)

  //------------------------------------------------------------
  //   Field: data                                    
  //   Width: 16             , Offset: 0              
  //   SW Access: read-write , HW Access: read-write  
  //------------------------------------------------------------
  //   Memory cell field
  //
  always @ (posedge clock or posedge reset)
  begin : reg_small_mem_data_small_mem_h_array_2
    // Reset
    if ( reset )
      data_small_mem_h_array_2 <= 16'hFFFF;
    // SW:read-write
    else if (wen_small_mem_h_array_2)
      data_small_mem_h_array_2 <= wdata;
    // HW:read-write
    else
      data_small_mem_h_array_2 <= data_small_mem_h_array_2_ip;
  end


  //------------------------------------------------------------
  // Register: small_mem
  //   Small register-based memory
  //   SW Access     : read-write
  //   Address Offset: 0x10
  //   HW Access     : read-write
  // 
  // Instance: small_mem_h_array_3
  //   Memory instances
  //   Address Offset: 0x16
  //   Reset Value   : 
  // 
  // Fields:
  //   15:0  data (SW:read-write, HW:read-write)

  //------------------------------------------------------------
  //   Field: data                                    
  //   Width: 16             , Offset: 0              
  //   SW Access: read-write , HW Access: read-write  
  //------------------------------------------------------------
  //   Memory cell field
  //
  always @ (posedge clock or posedge reset)
  begin : reg_small_mem_data_small_mem_h_array_3
    // Reset
    if ( reset )
      data_small_mem_h_array_3 <= 16'hFFFF;
    // SW:read-write
    else if (wen_small_mem_h_array_3)
      data_small_mem_h_array_3 <= wdata;
    // HW:read-write
    else
      data_small_mem_h_array_3 <= data_small_mem_h_array_3_ip;
  end


  //------------------------------------------------------------
  // Register: small_mem
  //   Small register-based memory
  //   SW Access     : read-write
  //   Address Offset: 0x10
  //   HW Access     : read-write
  // 
  // Instance: small_mem_h_array_4
  //   Memory instances
  //   Address Offset: 0x18
  //   Reset Value   : 
  // 
  // Fields:
  //   15:0  data (SW:read-write, HW:read-write)

  //------------------------------------------------------------
  //   Field: data                                    
  //   Width: 16             , Offset: 0              
  //   SW Access: read-write , HW Access: read-write  
  //------------------------------------------------------------
  //   Memory cell field
  //
  always @ (posedge clock or posedge reset)
  begin : reg_small_mem_data_small_mem_h_array_4
    // Reset
    if ( reset )
      data_small_mem_h_array_4 <= 16'hFFFF;
    // SW:read-write
    else if (wen_small_mem_h_array_4)
      data_small_mem_h_array_4 <= wdata;
    // HW:read-write
    else
      data_small_mem_h_array_4 <= data_small_mem_h_array_4_ip;
  end


  //------------------------------------------------------------
  // Register: small_mem
  //   Small register-based memory
  //   SW Access     : read-write
  //   Address Offset: 0x10
  //   HW Access     : read-write
  // 
  // Instance: small_mem_h_array_5
  //   Memory instances
  //   Address Offset: 0x1a
  //   Reset Value   : 
  // 
  // Fields:
  //   15:0  data (SW:read-write, HW:read-write)

  //------------------------------------------------------------
  //   Field: data                                    
  //   Width: 16             , Offset: 0              
  //   SW Access: read-write , HW Access: read-write  
  //------------------------------------------------------------
  //   Memory cell field
  //
  always @ (posedge clock or posedge reset)
  begin : reg_small_mem_data_small_mem_h_array_5
    // Reset
    if ( reset )
      data_small_mem_h_array_5 <= 16'hFFFF;
    // SW:read-write
    else if (wen_small_mem_h_array_5)
      data_small_mem_h_array_5 <= wdata;
    // HW:read-write
    else
      data_small_mem_h_array_5 <= data_small_mem_h_array_5_ip;
  end


  //------------------------------------------------------------
  // Register: small_mem
  //   Small register-based memory
  //   SW Access     : read-write
  //   Address Offset: 0x10
  //   HW Access     : read-write
  // 
  // Instance: small_mem_h_array_6
  //   Memory instances
  //   Address Offset: 0x1c
  //   Reset Value   : 
  // 
  // Fields:
  //   15:0  data (SW:read-write, HW:read-write)

  //------------------------------------------------------------
  //   Field: data                                    
  //   Width: 16             , Offset: 0              
  //   SW Access: read-write , HW Access: read-write  
  //------------------------------------------------------------
  //   Memory cell field
  //
  always @ (posedge clock or posedge reset)
  begin : reg_small_mem_data_small_mem_h_array_6
    // Reset
    if ( reset )
      data_small_mem_h_array_6 <= 16'hFFFF;
    // SW:read-write
    else if (wen_small_mem_h_array_6)
      data_small_mem_h_array_6 <= wdata;
    // HW:read-write
    else
      data_small_mem_h_array_6 <= data_small_mem_h_array_6_ip;
  end


  //------------------------------------------------------------
  // Register: small_mem
  //   Small register-based memory
  //   SW Access     : read-write
  //   Address Offset: 0x10
  //   HW Access     : read-write
  // 
  // Instance: small_mem_h_array_7
  //   Memory instances
  //   Address Offset: 0x1e
  //   Reset Value   : 
  // 
  // Fields:
  //   15:0  data (SW:read-write, HW:read-write)

  //------------------------------------------------------------
  //   Field: data                                    
  //   Width: 16             , Offset: 0              
  //   SW Access: read-write , HW Access: read-write  
  //------------------------------------------------------------
  //   Memory cell field
  //
  always @ (posedge clock or posedge reset)
  begin : reg_small_mem_data_small_mem_h_array_7
    // Reset
    if ( reset )
      data_small_mem_h_array_7 <= 16'hFFFF;
    // SW:read-write
    else if (wen_small_mem_h_array_7)
      data_small_mem_h_array_7 <= wdata;
    // HW:read-write
    else
      data_small_mem_h_array_7 <= data_small_mem_h_array_7_ip;
  end


  //----------------------------------------------------------------------
  //                    READ BUS MULTIPLEXER
  //----------------------------------------------------------------------
  assign rmux_status_reg_h[15:1] = DEF_RDATA_VAL[15:1]; // Default read value for RESERVED field - reserved
  assign rmux_status_reg_h[0] = ctrl_bit_status_reg_h;

  assign rmux_RegA_h = data_RegA_h;

  assign rmux_RegB_h = data_RegB_h;

  assign rmux_small_mem_h_array_0 = data_small_mem_h_array_0;

  assign rmux_small_mem_h_array_1 = data_small_mem_h_array_1;

  assign rmux_small_mem_h_array_2 = data_small_mem_h_array_2;

  assign rmux_small_mem_h_array_3 = data_small_mem_h_array_3;

  assign rmux_small_mem_h_array_4 = data_small_mem_h_array_4;

  assign rmux_small_mem_h_array_5 = data_small_mem_h_array_5;

  assign rmux_small_mem_h_array_6 = data_small_mem_h_array_6;

  assign rmux_small_mem_h_array_7 = data_small_mem_h_array_7;

  always @ ( * )
  begin : read_bus_mux
    // PUT REGISTER VALUE ON READ DATA BUS
    rack = 1'b0;
    raddrerr = 1'b0;
    if (rstrobe )
    begin
      case (raddr )
        STATUS_REG_H_ADDR:
        begin
          rdata = rmux_status_reg_h;
        end
        REGA_H_ADDR:
        begin
          rdata = rmux_RegA_h;
        end
        REGB_H_ADDR:
        begin
          rdata = rmux_RegB_h;
        end
        SMALL_MEM_H_ARRAY_0_ADDR:
        begin
          rdata = rmux_small_mem_h_array_0;
        end
        SMALL_MEM_H_ARRAY_1_ADDR:
        begin
          rdata = rmux_small_mem_h_array_1;
        end
        SMALL_MEM_H_ARRAY_2_ADDR:
        begin
          rdata = rmux_small_mem_h_array_2;
        end
        SMALL_MEM_H_ARRAY_3_ADDR:
        begin
          rdata = rmux_small_mem_h_array_3;
        end
        SMALL_MEM_H_ARRAY_4_ADDR:
        begin
          rdata = rmux_small_mem_h_array_4;
        end
        SMALL_MEM_H_ARRAY_5_ADDR:
        begin
          rdata = rmux_small_mem_h_array_5;
        end
        SMALL_MEM_H_ARRAY_6_ADDR:
        begin
          rdata = rmux_small_mem_h_array_6;
        end
        SMALL_MEM_H_ARRAY_7_ADDR:
        begin
          rdata = rmux_small_mem_h_array_7;
        end
        default:
        begin
          rdata =  DEF_RDATA_VAL;
          raddrerr =  1'b1;
        end
      endcase
      rack = 1'b1;
    end
    else
      begin
        rdata =  DEF_RDATA_VAL;
      end
  end
endmodule

