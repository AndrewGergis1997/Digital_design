//----------------------------------------------------------------------
//   THIS IS AUTOMATICALLY GENERATED CODE
//   Generated by Mentor Graphics' Register Assistant V4.2 (Build 2)
//   UVM Register Kit version 1.1
//----------------------------------------------------------------------
// Project         : Output
// Unit            : Output_pkg_uvm
// File            : Output_pkg_uvm.sv
//----------------------------------------------------------------------
// Created by      : user
// Creation Date   : 04/12/12 13:52
//----------------------------------------------------------------------
// Title           : Output
//
// Description     : 
//
//----------------------------------------------------------------------

//----------------------------------------------------------------------
// Output_pkg_uvm
//----------------------------------------------------------------------
package Output_pkg_uvm;

   import uvm_pkg::*;

   `include "uvm_macros.svh"

   /* DEFINE REGISTER CLASSES */



   //--------------------------------------------------------------------
   // Class: small_mem
   // 
   // Small register-based memory
   //--------------------------------------------------------------------

   class small_mem extends uvm_reg;
      `uvm_object_utils(small_mem)

      rand uvm_reg_field data; // Memory cell field


      // Function: new
      // 
      function new(string name = "small_mem");
         super.new(name, 16, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         data = uvm_reg_field::type_id::create("data");

         data.configure(this, 16, 0, "RW", 0, 16'hffff, 1, 1, 1);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: status_reg
   // 
   // Status register
   //--------------------------------------------------------------------

   class status_reg extends uvm_reg;
      `uvm_object_utils(status_reg)

      uvm_reg_field reserved; // Reserved
      rand uvm_reg_field ctrl_bit; // Control bit


      // Function: coverage
      // 
      covergroup cg_vals;
         ctrl_bit	 : coverpoint ctrl_bit.value[0];
      endgroup



      // Function: new
      // 
      function new(string name = "status_reg");
         super.new(name, 16, build_coverage(UVM_CVR_FIELD_VALS));
         add_coverage(build_coverage(UVM_CVR_FIELD_VALS));
         if(has_coverage(UVM_CVR_FIELD_VALS))
            cg_vals = new();
      endfunction


      // Function: sample_values
      // 
      virtual function void sample_values();
         super.sample_values();
         if (get_coverage(UVM_CVR_FIELD_VALS))
            cg_vals.sample();
      endfunction


      // Function: build
      // 
      virtual function void build();
         reserved = uvm_reg_field::type_id::create("reserved");
         ctrl_bit = uvm_reg_field::type_id::create("ctrl_bit");

         reserved.configure(this, 15, 1, "RW", 0, 15'b000000000000000, 1, 0, 0);
         ctrl_bit.configure(this, 1, 0, "RW", 0, 1'b0, 1, 1, 0);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: RegA
   // 
   // Register A
   //--------------------------------------------------------------------

   class RegA extends uvm_reg;
      `uvm_object_utils(RegA)

      rand uvm_reg_field data; // RegisterA field


      // Function: coverage
      // 
      covergroup cg_vals;
         data	 : coverpoint data.value[15:0];
      endgroup



      // Function: new
      // 
      function new(string name = "RegA");
         super.new(name, 16, build_coverage(UVM_CVR_FIELD_VALS));
         add_coverage(build_coverage(UVM_CVR_FIELD_VALS));
         if(has_coverage(UVM_CVR_FIELD_VALS))
            cg_vals = new();
      endfunction


      // Function: sample_values
      // 
      virtual function void sample_values();
         super.sample_values();
         if (get_coverage(UVM_CVR_FIELD_VALS))
            cg_vals.sample();
      endfunction


      // Function: build
      // 
      virtual function void build();
         data = uvm_reg_field::type_id::create("data");

         data.configure(this, 16, 0, "RW", 0, 16'h0000, 1, 1, 1);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: RegB
   // 
   // Register B
   //--------------------------------------------------------------------

   class RegB extends uvm_reg;
      `uvm_object_utils(RegB)

      rand uvm_reg_field data; // Register B field


      // Function: new
      // 
      function new(string name = "RegB");
         super.new(name, 16, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         data = uvm_reg_field::type_id::create("data");

         data.configure(this, 16, 0, "RW", 0, 16'h0000, 1, 1, 1);
      endfunction
   endclass




   /* BLOCKS */



   //--------------------------------------------------------------------
   // Class: reg_block_bus_map_coverage
   // 
   // Coverage for the 'bus_map' in 'reg_block'
   //--------------------------------------------------------------------

   class reg_block_bus_map_coverage extends uvm_object;
      `uvm_object_utils(reg_block_bus_map_coverage)

      covergroup ra_cov(string name) with function sample(uvm_reg_addr_t addr, bit is_read);

         option.per_instance = 1;
         option.name = name; 

         ADDR: coverpoint addr {
            bins status_reg_h = {'h0};
            bins RegA_h = {'h2};
            bins RegB_h = {'h4};
            bins small_mem_h[8] = {'h10, 
                                   'h12,
                                   'h14,
                                   'h16,
                                   'h18,
                                   'h1a,
                                   'h1c,
                                   'h1e};
         }

         RW: coverpoint is_read {
            bins RD = {1};
            bins WR = {0};
         }

         ACCESS: cross ADDR, RW;

      endgroup: ra_cov

      function new(string name = "reg_block_bus_map_coverage");
         ra_cov = new(name);
      endfunction: new

      function void sample(uvm_reg_addr_t offset, bit is_read);
         ra_cov.sample(offset, is_read);
      endfunction: sample

   endclass: reg_block_bus_map_coverage



   //--------------------------------------------------------------------
   // Class: reg_block
   // 
   // Register Block
   //--------------------------------------------------------------------

   class reg_block extends uvm_reg_block;
      `uvm_object_utils(reg_block)

      rand status_reg status_reg_h; // Status register instance
      rand RegA RegA_h; // Reg A instance
      rand RegB RegB_h; // Reg B instance
      rand small_mem small_mem_h[8]; // Memory instances

      uvm_reg_map bus_map; // reg_block bus map
      reg_block_bus_map_coverage bus_map_cg;


      // Function: new
      // 
      function new(string name = "reg_block");
         super.new(name, build_coverage(UVM_CVR_ALL));
      endfunction


      // Function: build
      // 
      virtual function void build();

         if(has_coverage(UVM_CVR_ADDR_MAP)) begin
            bus_map_cg = reg_block_bus_map_coverage::type_id::create("bus_map_cg");
            bus_map_cg.ra_cov.set_inst_name(this.get_full_name());
            void'(set_coverage(UVM_CVR_ADDR_MAP));
         end
         status_reg_h = status_reg::type_id::create("status_reg_h");
         status_reg_h.configure(this);
         status_reg_h.build();

         RegA_h = RegA::type_id::create("RegA_h");
         RegA_h.configure(this);
         RegA_h.build();

         RegB_h = RegB::type_id::create("RegB_h");
         RegB_h.configure(this);
         RegB_h.build();

         foreach ( small_mem_h[i] ) begin
            small_mem_h[i] = small_mem::type_id::create($psprintf("small_mem_h[%0d]", i));
            small_mem_h[i].configure(this);
            small_mem_h[i].build();
         end

         bus_map = create_map("bus_map", 'h0, 2, UVM_LITTLE_ENDIAN);
         default_map = bus_map;

         bus_map.add_reg(status_reg_h, 'h0, "RW");
         bus_map.add_reg(RegA_h, 'h2, "RW");
         bus_map.add_reg(RegB_h, 'h4, "RW");
         foreach(small_mem_h[i]) begin
            bus_map.add_reg(small_mem_h[i], (i * ('h2)) + ('h10), "RW");
         end

         uvm_resource_db #(bit)::set({"REG::", this.RegB_h.get_full_name()}, "NO_REG_HW_RESET_TEST", 1);
         lock_model();
      endfunction


      // Function: sample
      // 
      function void sample(uvm_reg_addr_t offset, bit is_read, uvm_reg_map  map);
         if(get_coverage(UVM_CVR_ADDR_MAP)) begin
            if(map.get_name() == "bus_map") begin
               bus_map_cg.sample(offset, is_read);
            end
         end
      endfunction: sample

   endclass


endpackage
