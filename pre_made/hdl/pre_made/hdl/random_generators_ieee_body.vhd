--
-- VHDL Package Body hds_package_library.random_generators_ieee
--
-- Created:
--
-- Generated by Mentor Graphics' HDL Designer(TM) 
--
LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
USE ieee.math_real.ALL;

PACKAGE BODY random_generators_ieee IS

-- Mathematical functions needed to perform the random number generation
    
    --pow - claulates powers for real numbers, different than math **, doesn't cause overflow

    FUNCTION pow ( val : REAL ; p : REAL) RETURN real is
    BEGIN
         if  not( p = real(integer(p)) ) then
            assert (val>0.0) report "Output for function pow is complex " severity FAILURE; 
         elsif ( (p/2.0) = real(integer(p/2.0)) ) then
            assert (val>0.0) report "Output for function pow is imaginary " severity FAILURE;
         end if;    
    RETURN (exp( p * log(val) ) );  
    END;
    
    -- gammln - Calculates the natural logarithmic value of a gamma function
    FUNCTION gammln  ( val : REAL )   RETURN  real IS
       type realarr is array (0 to 5) of real;
       variable x, y, tmp, ser, finalval : real;
       constant cof : realarr := 
               ( 0 =>  76.18009172947146,
                 1 => -86.50532032941677,
                 2 =>  24.01409824083091,
                 3 => -1.231739572450155,
                 4 =>  0.1208650973866179e-2,
                 5 => -0.5395239384953e-5
                );
    BEGIN
       assert (val>0.0) report "Function gammln called on negative or zero value" severity FAILURE;
       y := val;
       x := val;
       tmp := x+5.5;
       tmp := tmp - (x+0.5) * log(tmp);
       ser := 1.000000000190015;
       for i in 0 to 5 loop
           y := y + 1.0;
           ser := ser + cof(i)/y;
       end loop;
       finalval := (-1.0)*tmp+log(2.5066282746310005*ser/x);
       RETURN finalval;
    END gammln;

-- Random number generation functions

    -- random - Returns a uniform number value between 0.0 and 1.0
    -- VHDL implementation of Park and Miller with Pays-Durham shuffle and added safeguards
    -- Reference Numerical Recipes In C book, Chapter 7, page 280

    PROCEDURE random ( variable seed : inout INTEGER; variable rndval : out REAL; variable iv : inout genstatus1) IS
       constant IA : integer := 16807;
       constant IM : integer := 2147483647;
       constant AM : real := (1.0/real(IM));
       constant IQ : integer := 127773;
       constant IR : integer := 2836;
       constant NTAB : integer := 32;
       constant NDIV : real := (1.0+(real(IM)-1.0)/real(NTAB));
       constant EPS  : real := 1.2e-7;
       constant RNMX : real := (1.0-EPS);
       variable temp : real;
       variable j, k : integer;
    BEGIN
       if (seed <= 0) then
          if ((-1*seed) < 1) then 
              seed := 1;
          else 
              seed := -1 * seed;
          end if;
          j := NTAB+7;      
          while (j >= 0) loop
              k := seed/IQ;
              seed := IA*(seed-k*IQ)-IR*k;
              if (seed < 0) then 
                  seed := seed + IM;
              end if;      
              if (j < NTAB) then 
                  iv(j) := seed;
              end if;
          j := j - 1;
          end loop;
          iv(NTAB) := iv(0);      
       end if;

       k := seed/IQ;
       seed := IA*(seed-k*IQ)-IR*k;
       if (seed < 0) then
           seed := seed + IM;
       end if;
       j := integer(floor(real(iv(NTAB))/real(NDIV)));
       iv(NTAB) := iv(j);  
       iv(j) := seed;
       temp := AM*real(iv(NTAB));
       if (temp > RNMX) then 
           rndval := RNMX;
       else 
           rndval := temp;
       end if;      

    END random;

    -- dist_uniform - Returns a uniform number value between start and end

    PROCEDURE dist_uniform (variable seed : inout INTEGER; variable rndval : out INTEGER; startpoint : REAL; endpoint : REAL; variable iv : inout genstatus1 ) IS
       variable rndval01 : real;      
    BEGIN

       random(seed, rndval01, iv);
       rndval := integer(startpoint + (endpoint-startpoint)*rndval01);

    END dist_uniform;

     -- dist_normal - Returns a random number with normal (Gaussian) distribution
     -- Reference Numerical Recipes In C  book, Chapter 7, page 289

    PROCEDURE dist_normal (variable seed : inout INTEGER; variable rndval : out INTEGER; mean : REAL; stddev : REAL; variable iv : inout genstatus1; variable iy : inout genstatus2 ) IS
       variable rand : real;      
    BEGIN
         assert (stddev>0.0) report "Standurd deviation is negative or zero" severity FAILURE;
         dist_normal ( seed , rand , mean , stddev , iv , iy );
         rndval := integer(rand);    

    END dist_normal;


    PROCEDURE dist_normal (variable seed : inout INTEGER; variable rndval : out REAL; mean : REAL; stddev : REAL; variable iv : inout genstatus1; variable iy : inout genstatus2 ) IS
       variable fac, rsq, v1, v2 : real;      
    BEGIN
    assert (stddev>0.0) report "Standurd deviation is negative or zero" severity FAILURE;

-- iy(0) represents variable "gset"
-- iv(NTAB+1) represents variable "iset" should be initialized to 0 before this procedure is called

       if ( seed < 0 ) then
          iv(NTAB+1) := 0;
       end if;
       if ( iv(NTAB+1) = 0 ) then
            random(seed, v1, iv);
            random(seed, v2, iv);
            v1:=2.0*v1 - 1.0;
            v2:=2.0*v2 - 1.0;
            rsq := v1*v1 + v2*v2 ;
            while ( rsq >= 1.0 or rsq = 0.0 ) loop
                 random(seed, v1, iv);
                 random(seed, v2, iv);
                 v1:=2.0*v1-1.0;
                 v2:=2.0*v2-1.0;
                 rsq := v1*v1+v2*v2;
            end loop;
            fac := sqrt(-2.0*log(rsq)/rsq);
            iy(0) := v1 * fac;
            iv(NTAB+1) := 1;
            rndval := v2 * fac * stddev + mean;
       else
            iv(NTAB+1) := 0;
            rndval := iy(0) * stddev + mean;            
       end if;
       
    END dist_normal;

    -- dist_exponential - Returns a random number with exponential distribution
    -- Reference Numerical Recipes In C book, Chapter 7, page 287

    PROCEDURE dist_exponential (variable seed : inout INTEGER; variable rndval : out INTEGER; mean : REAL; variable iv : inout genstatus1 ) IS
       variable rand : real;      
    BEGIN
    
       dist_exponential(seed,rand,mean,iv);  
       rndval := integer(rand);
       
    END dist_exponential;

    PROCEDURE dist_exponential (variable seed : inout INTEGER; variable rndval : out REAL; mean : REAL; variable iv : inout genstatus1 ) IS
       variable rndval01 : real := 0.0;      
    BEGIN

       while ( rndval01 = 0.0 ) loop
           random(seed, rndval01, iv);
       end loop;

       rndval := -1.0 * mean * log(rndval01);

    END dist_exponential;

     -- dist_poisson - Returns a random number with poisson distribution
     -- Reference Numerical Recipes In C book, Chapter 7, page 294

    PROCEDURE dist_poisson (variable seed : inout INTEGER; variable rndval : out INTEGER; mean : REAL; variable iv : inout genstatus1; variable iy : inout genstatus2 ) IS
       variable em, t, y, ran1val : real;      
    BEGIN
   
-- iy(3) represents oldm, should be initialized to -1.0 before this procedure is called
-- iy(2) represents variable "g"
-- iy(1) represents variable "alxm"
-- iy(0) represents variable "sq"

       if ( mean < 12.0 ) then
            if (mean /= iy(3)) then           
                  iy(3) := mean;
                  iy(2) := exp(-1.0*mean); 
            end if;
            em := -1.0;
            t := 1.0;
            while (true) loop
                 em := em + 1.0;
                 random(seed, ran1val, iv);
                 t := t * ran1val;         
                 if ( t <= iy(2) ) then
                      exit;
                 end if;
            end loop;
       else
            if (mean /= iy(3)) then           
                  iy(3) := mean;
                  iy(0) := sqrt(2.0 * mean);
                  iy(1) := log(mean);
                  iy(2) := mean*iy(1)-gammln(mean+1.0);
            end if;
            while (true) loop
                  while (true) loop
                      random(seed, ran1val, iv);
                      y := tan(PI*ran1val);
                      em := iy(0)*y+mean;
		            if ( em >= 0.0 ) then
  		            	exit;
    		            end if;
                  end loop;
            em := floor(em);
            t := 0.9*(1.0+y*y)*exp(em*iy(1)-gammln(em+1.0)-iy(2));

            random(seed, ran1val, iv);
            if ( ran1val <= t ) then
                  exit;
            end if;
            end loop;
 
       end if;
                rndval := integer(em);
    END dist_poisson;
    
    -- dist_gamma - Returns a random number with gamma distribution
    -- Reference   L. Devroye, "Non-Uniform Random Variate Generation" 
    
    PROCEDURE dist_gamma (variable seed : inout INTEGER; variable rndval : out REAL; alpha : REAL; beta : REAL; variable iv : inout genstatus1) IS
    variable c,d,u,v,x,e,y,aa,bb,w,z,r,zlog,xlog,xy,bby,v2,w3,y2 : real ;  
    BEGIN
      
      r :=0.0; 
      assert ((alpha >0.0) and (beta>0.0)) report "gamma distribution with one or more negative parameters" severity FAILURE;
      
      if ( alpha =1.0 )  then
          
          -- If alpha == 1, then gamma is exponential. (Devroye, page 405).
          
          dist_exponential(seed,rndval,beta,iv);  
          
      elsif ( alpha < 1.0 ) then
          
          -- (Devroye, page 418 - Johnk's generator)
          
          c := 1.0/alpha ;
          d := 1.0/(1.0-alpha);
          while (r=0.0) loop
             random ( seed , u , iv );
             random ( seed , v , iv );
             x := pow(u,c);
             y := pow(v,d); 
             if ( (x+y) <= 1.0) then
                 random ( seed , aa , iv );
                 e := -log(aa);
                 r := e*x/(x+y);
             end if;
          end loop; 
          r:=r*beta;
      else
          -- Use a rejection method for alpha > 1.
          -- (Devroye, page 410 Best's algorithm)

          bb := alpha-1.0;     
          c  := 3.0 * alpha - ( 3.0/4.0);
          while (r=0.0) loop
              random ( seed , u , iv );
              random ( seed , v , iv );
              w := u * (1.0-u);
              y := sqrt(c/w) * (u-0.5);
              x := bb + y;
              if ( x >= 0.0) then 
                 w3:=w*w*w;
                 v2:=v*v;
                 z := 64.0 * w3 * v2;
                 y2:= y*y;
                 zlog := log(z);
                 xlog:=log(x/bb);
                 xy := (1.0- (2.0*y2/x));
                 bby :=2.0*( (bb * xlog) - y );
                 if ( z <= xy)  then
                    r := x;
                 elsif  (zlog <= bby ) then
                    r := x ;
                 end if ;
              end if ;
          end loop;
          r := r * beta;
      end if ;
      rndval := r ;
    END dist_gamma; 
   
    -- dist_chi_square - Returns a random number with chi-squared distribution
    -- Reference  L. Devroye, "Non-Uniform Random Variate Generation"

    PROCEDURE dist_chi_square (variable seed : inout INTEGER; variable rndval : out INTEGER ; n : REAL ; variable iv : inout genstatus1) IS 
    variable a,b, rand : real;
   
    BEGIN
       b := 2.0;
       a := n/2.0;
       dist_gamma(seed,rand,a,b,iv);
       rndval := integer(rand);
    END dist_chi_square;

    --dist_erlang - Returns a random number with erlang distribution
    --use gamma_dist with alpha being intrger...  
    PROCEDURE dist_erlang(variable seed : inout INTEGER; variable rndval : out INTEGER ; alpha : REAL ;beta : REAL; variable iv : inout genstatus1) IS
       variable alpha1, rand : real;
    
    BEGIN
       alpha1 := real(floor(alpha));
       dist_gamma(seed,rand,alpha1,beta,iv);
       rndval := integer(rand);
    END dist_erlang;
    
   -- dist_t -  Returns a random number with t distribution
   -- Refrence  L. Devroye, "Non-Uniform Random Variate Generation"
  
   PROCEDURE dist_t (variable seed : inout INTEGER; variable rndval : out INTEGER ; n : REAL ; variable iv : inout genstatus1;variable iy: inout genstatus2) IS 
      variable r,u,v,x : real; 
   BEGIN
      assert (n>0.0) report "No. of degrees of freedom must be postive " severity FAILURE;
      r :=0.0;
      if (n = 1.0) then  -- When n = 1 the T and Cauchy distributions are the same.
                         -- Generate Cauchy random numbers as a ratio of normal. 
                         --Devroye p. 451. 

         dist_normal ( seed , u , 0.0 , 1.0 , iv , iy );  
         dist_normal ( seed , v , 0.0 , 1.0 , iv , iy );   
         r := u/v;
      elsif (r=2.0) then
                         --When n = 2, express T random numbers as a function of uniform
                         --random numbers.  See Devroye, page 430, Theorem 4.1, part C.


         random ( seed , u , iv );
         r := sqrt(2.0) * (u - 0.5) / sqrt(u*(1.0-u));
      
          else
                       -- Otherwise, express t random numbers as a function of symmetric
                       -- beta random numbers. See Devroye, page 446, number 3.


         dist_beta(seed,x,(n/2.0),(n/2.0),iv); 
         r := sqrt(n) * (x - 0.5) / sqrt(x * (1.0 - x));
      end if;
      rndval  := integer(r) ;   
   END dist_t;

   --dist_beta - Returns a random number with beta distribution
   --Use Theorem 4.1, case A (Devroye, page 430) to derive beta
   -- random numbers as a ratio of gamma random numbers.

   PROCEDURE dist_beta (variable seed : inout INTEGER; variable rndval : out REAL ; a : REAL ; b : REAL ; variable iv : inout genstatus1) IS  
      variable g1 , g2 : real;
   BEGIN
      assert ((a >0.0) and (b>0.0)) report "beta distribution with one or more negative parameters" severity FAILURE;
      random ( seed , g1 , iv ) ;
      random ( seed , g2 , iv ) ;
      rndval := ( g1 / (g1+g2) ) ;
   END dist_beta;

END random_generators_ieee;

